/**
 * Workbox Integration for App Bootstrap Library
 * Created: 2024-07-31
 * Purpose: Provides PWA functionality with service worker generation and caching strategies
 */

import type { AppBootstrapOptions, AssetManifest } from './types';

export interface WorkboxOptions {
    /** Enable/disable Workbox integration */
    enabled?: boolean;
    /** Cache name prefix */
    cacheNamePrefix?: string;
    /** Cache strategies for different file types */
    strategies?: {
        /** Strategy for JavaScript files */
        js?: 'cache-first' | 'stale-while-revalidate' | 'network-first';
        /** Strategy for CSS files */
        css?: 'cache-first' | 'stale-while-revalidate' | 'network-first';
        /** Strategy for images */
        images?: 'cache-first' | 'stale-while-revalidate' | 'network-first';
        /** Strategy for HTML files */
        html?: 'cache-first' | 'stale-while-revalidate' | 'network-first';
        /** Strategy for API calls */
        api?: 'cache-first' | 'stale-while-revalidate' | 'network-first';
    };
    /** Cache expiration settings */
    expiration?: {
        /** Maximum number of entries in cache */
        maxEntries?: number;
        /** Maximum age in seconds */
        maxAgeSeconds?: number;
    };
    /** Precache assets */
    precache?: boolean;
    /** Background sync for offline actions */
    backgroundSync?: boolean;
}

const DEFAULT_WORKBOX_OPTIONS: Required<WorkboxOptions> = {
    enabled: true,
    cacheNamePrefix: 'celebrity-box',
    strategies: {
        js: 'stale-while-revalidate',
        css: 'stale-while-revalidate',
        images: 'cache-first',
        html: 'network-first',
        api: 'network-first'
    },
    expiration: {
        maxEntries: 100,
        maxAgeSeconds: 86400 // 24 hours
    },
    precache: true,
    backgroundSync: false
};

/**
 * Generate Workbox service worker content
 */
export function generateWorkboxServiceWorker(
    assetManifest: AssetManifest,
    options: AppBootstrapOptions,
    workboxOptions: WorkboxOptions = {}
): string {
    const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };

    if (!opts.enabled) {
        return generateMinimalServiceWorker(assetManifest, options);
    }

    const cacheName = `${opts.cacheNamePrefix}-v1`;
    const { appName } = options;

    return `/**
 * Service Worker - Generated by @basirah/app-bootstrap-lib
 * App: ${appName}
 * Created: ${new Date().toISOString()}
 */

const CACHE_NAME = '${cacheName}';
const STATIC_CACHE = '${cacheName}-static';
const DYNAMIC_CACHE = '${cacheName}-dynamic';

// Assets to precache
const PRECACHE_ASSETS = [
  '/',
  '/index.html',
  '/AppBootstrap.js',
  '/asset-manifest.js',
${assetManifest.loadingSequence.js.map(js => `  '/${js}',`).join('\n')}
${assetManifest.loadingSequence.css.map(css => `  '/${css}',`).join('\n')}
];

// Install event - precache assets
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('[SW] Pre-caching app shell');
        return cache.addAll(PRECACHE_ASSETS);
      })
      .then(() => {
        console.log('[SW] Successfully installed');
        return self.skipWaiting();
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
              console.log('[SW] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('[SW] Successfully activated');
        return self.clients.claim();
      })
  );
});

// Fetch event - handle requests
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Handle different file types with different strategies
  if (url.pathname.endsWith('.js')) {
    event.respondWith(handleJSRequest(request));
  } else if (url.pathname.endsWith('.css')) {
    event.respondWith(handleCSSRequest(request));
  } else if (url.pathname.match(/\\.(png|jpg|jpeg|svg|gif|ico)$/)) {
    event.respondWith(handleImageRequest(request));
  } else if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleAPIRequest(request));
  } else {
    event.respondWith(handleHTMLRequest(request));
  }
});

// Cache First strategy for images
async function handleImageRequest(request) {
  try {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.error('[SW] Image fetch failed:', error);
    return new Response('Image not available', { status: 404 });
  }
}

// Stale While Revalidate for JS/CSS
async function handleJSRequest(request) {
  return handleStaleWhileRevalidate(request, STATIC_CACHE);
}

async function handleCSSRequest(request) {
  return handleStaleWhileRevalidate(request, STATIC_CACHE);
}

// Network First for HTML
async function handleHTMLRequest(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.log('[SW] Network failed, trying cache...');
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    return caches.match('/index.html');
  }
}

// Network First for API calls
async function handleAPIRequest(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.log('[SW] API network failed, trying cache...');
    return await caches.match(request);
  }
}

// Stale While Revalidate strategy
async function handleStaleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(request);

  const fetchPromise = fetch(request).then((networkResponse) => {
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  }).catch(() => {
    console.log('[SW] Network failed for:', request.url);
  });

  return cachedResponse || fetchPromise;
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    console.log('[SW] Background sync triggered');
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // Handle offline actions here
  console.log('[SW] Processing background sync...');
}

// Push notifications
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'New notification from ${appName}',
    icon: '/icon-192x192.png',
    badge: '/icon-192x192.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    }
  };

  event.waitUntil(
    self.registration.showNotification('${appName}', options)
  );
});

// Notification click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.openWindow('/')
  );
});

console.log('[SW] Service worker loaded successfully');
`;
}

/**
 * Generate minimal service worker (fallback)
 */
function generateMinimalServiceWorker(
    _assetManifest: AssetManifest,
    options: AppBootstrapOptions
): string {
    return `/**
 * Minimal Service Worker - Generated by @basirah/app-bootstrap-lib
 * App: ${options.appName}
 * Created: ${new Date().toISOString()}
 */

self.addEventListener('install', (event) => {
  console.log('[SW] Installing minimal service worker...');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating minimal service worker...');
  self.clients.claim();
});

self.addEventListener('fetch', (event) => {
  // Basic caching for offline support
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});

console.log('[SW] Minimal service worker loaded');
`;
}

/**
 * Generate service worker registration script
 */
export function generateServiceWorkerRegistration(
    options: AppBootstrapOptions,
    workboxOptions: WorkboxOptions = {}
): string {
    const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };

    if (!opts.enabled) {
        return '';
    }

    return `/**
 * Service Worker Registration - Generated by @basirah/app-bootstrap-lib
 * App: ${options.appName}
 */

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('[SW] Registration successful:', registration.scope);

        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New content is available
              console.log('[SW] New content available');
              // You can show a notification to the user here
            }
          });
        });
      })
      .catch((error) => {
        console.error('[SW] Registration failed:', error);
      });
  });
}

// Background sync registration
if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
  navigator.serviceWorker.ready.then((registration) => {
    // Register background sync
    registration.sync.register('background-sync');
  });
}
`;
}

/**
 * Generate PWA manifest with Workbox integration
 */
export function generatePWAManifest(
    options: AppBootstrapOptions,
    _workboxOptions: WorkboxOptions = {},
    pwaConfig?: any
): string {
    // Use PWA config if provided, otherwise use defaults
    const manifestConfig = pwaConfig?.manifest || {};

    const manifest = {
        name: manifestConfig.name || options.appName || 'App',
        short_name: manifestConfig.short_name || (options.appName || 'App').replace(/\s+/g, '').substring(0, 12),
        description: manifestConfig.description || `PWA for ${options.appName || 'App'} with offline support`,
        theme_color: manifestConfig.theme_color || (options.loadingTheme === 'gradient' ? '#667eea' : '#2c3e50'),
        background_color: manifestConfig.background_color || '#ffffff',
        display: manifestConfig.display || 'standalone',
        orientation: manifestConfig.orientation || 'portrait',
        scope: manifestConfig.scope || '/',
        start_url: manifestConfig.start_url || '/',
        icons: manifestConfig.icons || [
            {
                src: '/icon-192x192.png',
                sizes: '192x192',
                type: 'image/png'
            },
            {
                src: '/icon-512x512.png',
                sizes: '512x512',
                type: 'image/png'
            },
            {
                src: '/icon-512x512.png',
                sizes: '512x512',
                type: 'image/png',
                purpose: 'maskable'
            }
        ],
        categories: ['utilities', 'productivity'],
        shortcuts: [
            {
                name: 'Home',
                short_name: 'Home',
                description: 'Go to home page',
                url: '/',
                icons: [{ src: '/icon-192x192.png', sizes: '192x192' }]
            }
        ]
    };

    return JSON.stringify(manifest, null, 2);
}
