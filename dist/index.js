'use strict';

var react = require('react');

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/vite.ts
var DEFAULT_PRIORITIES = {
  "vendor": 1,
  "main": 2,
  "app": 3,
  "chunk": 4
};
function generateChunkConfiguration(customChunks = {}) {
  const chunks = {
    vendor: ["react", "react-dom"],
    ...customChunks
  };
  return chunks;
}
function analyzeBuildOutput(bundle, priorities, assetPrefix = "") {
  const js = {};
  const css = {};
  let totalOriginalSize = 0;
  for (const [fileName, file] of Object.entries(bundle)) {
    const fileInfo = file;
    const filePath = assetPrefix + "/" + fileName;
    if (fileName.endsWith(".js")) {
      js[fileName] = filePath;
      totalOriginalSize += fileInfo.code?.length || 0;
    } else if (fileName.endsWith(".css")) {
      css[fileName] = filePath;
      totalOriginalSize += fileInfo.source?.length || 0;
    }
  }
  const loadingSequence = {
    js: Object.keys(js).sort((a, b) => {
      const priorityA = priorities[a] || 999;
      const priorityB = priorities[b] || 999;
      return priorityA - priorityB;
    }),
    css: Object.keys(css)
  };
  return {
    js,
    css,
    loadingSequence,
    totalOriginalSize,
    buildInfo: {
      timestamp: Date.now(),
      version: "1.0.0",
      appName: "App",
      compressionEnabled: false,
      chunksGenerated: Object.keys(js).length,
      plugin: "app-bootstrap-lib"
    }
  };
}
function transformIndexHtml(html, options) {
  const bootstrapScript = `<script src="/${options.bootstrapFileName}"></script>`;
  if (html.includes("</head>")) {
    return html.replace("</head>", `  ${bootstrapScript}
</head>`);
  }
  return bootstrapScript + "\n" + html;
}
function generateAppBootstrap(assetManifest, options) {
  const { appName, loadingTheme, customTheme } = options;
  const themeCSS = customTheme || (loadingTheme === "gradient" ? "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" : "background: #2c3e50;");
  return `/**
 * AppBootstrap.js - Generated by app-bootstrap-lib
 * Created: ${(/* @__PURE__ */ new Date()).toISOString()}
 */

(function() {
  'use strict';

  // Asset manifest
  window.ASSET_MANIFEST = ${JSON.stringify(assetManifest, null, 2)};

  // Loading state
  window.APP_BOOTSTRAP_LOADING_STATE = {
    isLoaded: false,
    isLoading: true,
    progress: 0,
    currentChunk: '',
    loadedChunks: [],
    totalChunks: ${assetManifest.loadingSequence.js.length},
    error: null,
    startTime: Date.now()
  };

  // Event emitter
  window.APP_BOOTSTRAP_EVENTS = {
    listeners: {},
    on: function(event, callback) {
      if (!this.listeners[event]) this.listeners[event] = [];
      this.listeners[event].push(callback);
    },
    emit: function(event, data) {
      if (this.listeners[event]) {
        this.listeners[event].forEach(cb => cb(data));
      }
    }
  };

  // Loading screen
  function createLoadingScreen() {
    const loadingHTML = \`
      <div id="loading-screen" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        ${themeCSS}
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        z-index: 9999;
      ">
        <div style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid white;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 20px;
        "></div>
        <p id="loading-text">Loading ${appName}...</p>
        <div id="loading-progress" style="
          width: 200px;
          height: 4px;
          background: rgba(255, 255, 255, 0.3);
          border-radius: 2px;
          margin-top: 10px;
          overflow: hidden;
        ">
          <div id="progress-bar" style="
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.3s ease;
          "></div>
        </div>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      </div>
    \`;

    document.body.insertAdjacentHTML('afterbegin', loadingHTML);
  }

  // Load assets
  async function loadAssets() {
    const { loadingSequence } = window.ASSET_MANIFEST;
    const totalChunks = loadingSequence.js.length + loadingSequence.css.length;
    let loadedChunks = 0;

    // Load CSS first
    for (const cssFile of loadingSequence.css) {
      try {
        await loadCSS(window.ASSET_MANIFEST.css[cssFile]);
        loadedChunks++;
        updateProgress(loadedChunks, totalChunks);
      } catch (error) {
        console.error('Failed to load CSS:', cssFile, error);
      }
    }

    // Load JS
    for (const jsFile of loadingSequence.js) {
      try {
        await loadJS(window.ASSET_MANIFEST.js[jsFile]);
        loadedChunks++;
        updateProgress(loadedChunks, totalChunks);
      } catch (error) {
        console.error('Failed to load JS:', jsFile, error);
      }
    }

    // Complete
    window.APP_BOOTSTRAP_LOADING_STATE.isLoaded = true;
    window.APP_BOOTSTRAP_LOADING_STATE.isLoading = false;
    window.APP_BOOTSTRAP_READY = true;

    window.APP_BOOTSTRAP_EVENTS.emit('loading:complete');
    hideLoadingScreen();
  }

  function loadCSS(href: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      link.onload = () => resolve();
      link.onerror = () => reject(new Error('CSS load failed: ' + href));
      document.head.appendChild(link);
    });
  }

  function loadJS(src: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error('JS load failed: ' + src));
      document.head.appendChild(script);
    });
  }

  function updateProgress(loaded: number, total: number) {
    const progress = Math.round((loaded / total) * 100);
    window.APP_BOOTSTRAP_LOADING_STATE.progress = progress;

    const progressBar = document.getElementById('progress-bar');
    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    window.APP_BOOTSTRAP_EVENTS.emit('loading:progress', { progress });
  }

  function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      loadingScreen.style.display = 'none';
    }
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      createLoadingScreen();
      loadAssets();
    });
  } else {
    createLoadingScreen();
    loadAssets();
  }
})();
`;
}
function generateDevModeFiles(opts, publicDir = "public") {
  const fs = __require("fs");
  const path = __require("path");
  const devAssetManifest = {
    js: {
      "main.js": "/src/main.tsx"
    },
    css: {},
    loadingSequence: {
      js: ["main.js"],
      css: []
    },
    totalOriginalSize: 0,
    buildInfo: {
      timestamp: Date.now(),
      version: "1.0.0-dev",
      appName: opts.appName,
      compressionEnabled: false,
      chunksGenerated: 1,
      plugin: "app-bootstrap-lib-dev"
    }
  };
  const devAppBootstrapContent = generateAppBootstrap(devAssetManifest, opts);
  const fullPublicDir = path.join(process.cwd(), publicDir);
  if (!fs.existsSync(fullPublicDir)) {
    fs.mkdirSync(fullPublicDir, { recursive: true });
  }
  const assetManifestPath = path.join(fullPublicDir, "asset-manifest.js");
  const assetManifestContent = `window.ASSET_MANIFEST = ${JSON.stringify(devAssetManifest, null, 2)};`;
  fs.writeFileSync(assetManifestPath, assetManifestContent);
  const appBootstrapPath = path.join(fullPublicDir, opts.bootstrapFileName);
  fs.writeFileSync(appBootstrapPath, devAppBootstrapContent);
  if (opts.debugMode) {
    console.log(`[app-bootstrap-lib] \u{1F4DD} Generated development files:`);
    console.log(`[app-bootstrap-lib] \u2705 ${opts.bootstrapFileName}`);
    console.log(`[app-bootstrap-lib] \u2705 asset-manifest.js`);
  }
}
function appBootstrapPlugin(options = {}) {
  let buildAssets;
  const opts = {
    enableGzip: false,
    debugMode: false,
    appName: "Application",
    loadingTheme: "gradient",
    customTheme: "",
    customChunks: {},
    chunkPriorities: {},
    assetPrefix: "",
    bootstrapFileName: "AppBootstrap.js",
    ...options
  };
  const priorities = { ...DEFAULT_PRIORITIES, ...opts.chunkPriorities };
  return {
    name: "app-bootstrap-lib",
    configureServer(server) {
      console.log("[app-bootstrap-lib] \u{1F680} Development server starting, generating bootstrap files...");
      const publicDir = server.config.publicDir || "public";
      console.log("[app-bootstrap-lib] \u{1F4C1} Public directory:", publicDir);
      generateDevModeFiles(opts, publicDir);
    },
    buildStart() {
      console.log("[app-bootstrap-lib] \u{1F680} Build starting, generating bootstrap files...");
      generateDevModeFiles(opts, "public");
    },
    config(config) {
      if (!config.build) config.build = {};
      config.build.cssCodeSplit = true;
      if (!config.build.rollupOptions) config.build.rollupOptions = {};
      if (!config.build.rollupOptions.output) config.build.rollupOptions.output = {};
      const output = config.build.rollupOptions.output;
      output.entryFileNames = "[name].js";
      output.chunkFileNames = "[name].js";
      output.assetFileNames = (assetInfo) => {
        if (!assetInfo.name) return "[name].[ext]";
        const info = assetInfo.name.split(".");
        const ext = info[info.length - 1];
        if (/\.(css)$/.test(assetInfo.name)) {
          return `assets/[name].${ext}`;
        }
        return "[name].[ext]";
      };
      const chunks = generateChunkConfiguration(opts.customChunks);
      output.manualChunks = chunks;
      if (opts.debugMode) {
        console.log("[app-bootstrap-lib] App name:", opts.appName);
        console.log("[app-bootstrap-lib] Theme:", opts.loadingTheme);
      }
      return config;
    },
    transformIndexHtml(html) {
      return transformIndexHtml(html, opts);
    },
    generateBundle(_options, bundle) {
      buildAssets = analyzeBuildOutput(bundle, priorities, opts.assetPrefix);
      const assetManifest = {
        ...buildAssets,
        buildInfo: {
          ...buildAssets.buildInfo,
          appName: opts.appName,
          compressionEnabled: opts.enableGzip,
          plugin: "app-bootstrap-lib"
        }
      };
      this.emitFile({
        type: "asset",
        fileName: "asset-manifest.js",
        source: `window.ASSET_MANIFEST = ${JSON.stringify(assetManifest, null, 2)};`
      });
      const appBootstrapContent = generateAppBootstrap(assetManifest, opts);
      this.emitFile({
        type: "asset",
        fileName: opts.bootstrapFileName,
        source: appBootstrapContent
      });
      if (opts.debugMode) {
        console.log(`[app-bootstrap-lib] \u2705 Generated ${opts.bootstrapFileName}`);
        console.log(`[app-bootstrap-lib] \u{1F4E6} Assets: ${Object.keys(buildAssets.js).length} JS, ${Object.keys(buildAssets.css).length} CSS`);
      }
    }
  };
}
var AppBootstrapEvents = class {
  constructor() {
    this.listeners = {};
  }
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
    return () => {
      this.listeners[event] = this.listeners[event].filter((cb) => cb !== callback);
    };
  }
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((callback) => callback(data));
    }
  }
};
var appBootstrapEvents = new AppBootstrapEvents();
function getAssetManifest() {
  return window.ASSET_MANIFEST || null;
}
function isAppBootstrapReady() {
  return window.APP_BOOTSTRAP_READY === true;
}
function getCurrentLoadingState() {
  return window.APP_BOOTSTRAP_LOADING_STATE || null;
}
function useAppBootstrap(config = {}) {
  const [loadingState, setLoadingState] = react.useState({
    isLoaded: false,
    isLoading: false,
    progress: 0,
    currentChunk: "",
    loadedChunks: [],
    totalChunks: 0,
    error: null,
    startTime: Date.now()
  });
  const [assetManifest, setAssetManifest] = react.useState(null);
  const [error, setError] = react.useState(null);
  const isReady = react.useRef(false);
  react.useEffect(() => {
    const currentState = getCurrentLoadingState();
    const currentManifest = getAssetManifest();
    if (currentState) {
      setLoadingState(currentState);
    }
    if (currentManifest) {
      setAssetManifest(currentManifest);
    }
    if (isAppBootstrapReady()) {
      isReady.current = true;
      setLoadingState((prev) => ({
        ...prev,
        isLoaded: true,
        isLoading: false,
        progress: 100
      }));
    }
  }, []);
  react.useEffect(() => {
    const unsubscribeStart = appBootstrapEvents.on("loading:start", (_event) => {
      setLoadingState((prev) => ({
        ...prev,
        isLoading: true,
        isLoaded: false,
        startTime: Date.now(),
        error: null
      }));
      setError(null);
    });
    const unsubscribeProgress = appBootstrapEvents.on("loading:progress", (event) => {
      setLoadingState((prev) => ({
        ...prev,
        progress: event.data?.progress || prev.progress
      }));
    });
    const unsubscribeComplete = appBootstrapEvents.on("loading:complete", (_event) => {
      isReady.current = true;
      setLoadingState((prev) => ({
        ...prev,
        isLoaded: true,
        isLoading: false,
        progress: 100,
        endTime: Date.now(),
        duration: Date.now() - prev.startTime
      }));
    });
    const unsubscribeError = appBootstrapEvents.on("loading:error", (event) => {
      const errorMessage = event.data?.error || "Unknown loading error";
      setError(errorMessage);
      setLoadingState((prev) => ({
        ...prev,
        isLoading: false,
        error: errorMessage
      }));
    });
    const unsubscribeManifestLoaded = appBootstrapEvents.on("manifest:loaded", (event) => {
      setAssetManifest(event.data?.manifest);
    });
    return () => {
      unsubscribeStart();
      unsubscribeProgress();
      unsubscribeComplete();
      unsubscribeError();
      unsubscribeManifestLoaded();
    };
  }, []);
  react.useEffect(() => {
    if (assetManifest || !config.enableDebug) return;
    const pollInterval = setInterval(() => {
      const manifest = getAssetManifest();
      if (manifest) {
        setAssetManifest(manifest);
        clearInterval(pollInterval);
      }
    }, 100);
    return () => clearInterval(pollInterval);
  }, [assetManifest, config.enableDebug]);
  react.useEffect(() => {
    if (isReady.current) return;
    const checkDevReady = () => {
      const rootElement = document.getElementById("root");
      if (rootElement && rootElement.children.length > 0) {
        const appContent = rootElement.querySelector(".app, .home-page, .system-config-page, .video-player-page");
        if (appContent) {
          console.log("[useAppBootstrap] Development mode: App content detected, marking as ready");
          isReady.current = true;
          setLoadingState((prev) => ({
            ...prev,
            isLoaded: true,
            isLoading: false,
            progress: 100,
            endTime: Date.now(),
            duration: Date.now() - prev.startTime
          }));
          return true;
        }
      }
      return false;
    };
    if (checkDevReady()) return;
    const pollInterval = setInterval(() => {
      if (checkDevReady()) {
        clearInterval(pollInterval);
      }
    }, 100);
    const timeout = setTimeout(() => {
      clearInterval(pollInterval);
      if (!isReady.current) {
        console.log("[useAppBootstrap] Development mode: Fallback timeout, marking as ready");
        isReady.current = true;
        setLoadingState((prev) => ({
          ...prev,
          isLoaded: true,
          isLoading: false,
          progress: 100,
          endTime: Date.now(),
          duration: Date.now() - prev.startTime
        }));
      }
    }, 3e3);
    return () => {
      clearInterval(pollInterval);
      clearTimeout(timeout);
    };
  }, []);
  const retry = react.useCallback(() => {
    setError(null);
    setLoadingState((prev) => ({
      ...prev,
      error: null,
      isLoading: true,
      isLoaded: false,
      startTime: Date.now()
    }));
    appBootstrapEvents.emit("loading:retry", { timestamp: Date.now() });
  }, []);
  const getChunkProgress = react.useCallback((chunkName) => {
    if (!assetManifest) return 0;
    const chunk = assetManifest.js[chunkName];
    return chunk ? 100 : 0;
  }, [assetManifest]);
  const getOverallProgress = react.useCallback(() => {
    return loadingState.progress;
  }, [loadingState.progress]);
  react.useEffect(() => {
    if (config.enableDebug) {
      console.log("[useAppBootstrap] Loading state:", loadingState);
      console.log("[useAppBootstrap] Asset manifest:", assetManifest);
      console.log("[useAppBootstrap] Error:", error);
    }
  }, [loadingState, assetManifest, error, config.enableDebug]);
  return {
    loadingState,
    assetManifest,
    isReady: isReady.current,
    error,
    retry,
    getChunkProgress,
    getOverallProgress
  };
}
function useAppBootstrapStatus() {
  const { loadingState, isReady, error } = useAppBootstrap();
  return {
    isReady,
    isLoading: loadingState.isLoading,
    isLoaded: loadingState.isLoaded,
    progress: loadingState.progress,
    error,
    currentChunk: loadingState.currentChunk
  };
}
function useAppBootstrapWithConfig(config) {
  return useAppBootstrap(config);
}

// src/cache.ts
var AppCacheManager = class {
  constructor(config = {}) {
    this.config = {
      cacheName: "app-bootstrap-v1",
      appVersion: "1.0.0",
      enableServiceWorker: true,
      loadingScreen: {
        theme: "gradient"
      },
      ...config
    };
    this.loadingElement = null;
  }
  async init() {
    console.log("App Cache Manager initializing...");
    this.setupLoadingScreen();
    await this.loadApp();
  }
  setupLoadingScreen() {
    const theme = this.config.loadingScreen?.theme || "gradient";
    const customHTML = this.config.loadingScreen?.customHTML;
    const loadingHTML = customHTML || this.getDefaultLoadingHTML(theme);
    document.body.insertAdjacentHTML("afterbegin", loadingHTML);
    this.loadingElement = document.getElementById("loading-screen");
  }
  getDefaultLoadingHTML(theme) {
    const baseStyles = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      z-index: 9999;
    `;
    const background = theme === "gradient" ? "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" : "background: #2c3e50;";
    return `
      <div id="loading-screen" style="${baseStyles} ${background}">
        <div style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid white;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 20px;
        "></div>
        <p id="loading-text">Loading Application...</p>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      </div>
    `;
  }
  updateLoadingText(text) {
    const loadingText = document.getElementById("loading-text");
    if (loadingText) {
      loadingText.textContent = text;
    }
  }
  async loadApp() {
    this.updateLoadingText("Loading application...");
    setTimeout(() => {
      this.hideLoadingScreen();
    }, 2e3);
  }
  hideLoadingScreen() {
    if (this.loadingElement) {
      this.loadingElement.style.display = "none";
    }
  }
  showError(message) {
    if (this.loadingElement) {
      this.loadingElement.innerHTML = `
        <div style="text-align: center;">
          <h3>Error</h3>
          <p>${message}</p>
          <button onclick="location.reload()" style="
            background: white;
            color: #667eea;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
          ">Retry</button>
        </div>
      `;
    }
  }
  retry() {
    location.reload();
  }
  // Service Worker registration - removed to simplify
};
function initializeCacheManager(config) {
  const manager = new AppCacheManager(config);
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      manager.init();
    });
  } else {
    manager.init();
  }
  return manager;
}

exports.AppCacheManager = AppCacheManager;
exports.appBootstrapEvents = appBootstrapEvents;
exports.appBootstrapPlugin = appBootstrapPlugin;
exports.initializeCacheManager = initializeCacheManager;
exports.useAppBootstrap = useAppBootstrap;
exports.useAppBootstrapStatus = useAppBootstrapStatus;
exports.useAppBootstrapWithConfig = useAppBootstrapWithConfig;
exports.vitePlugin = appBootstrapPlugin;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map