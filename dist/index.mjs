import { useState, useRef, useEffect, useCallback } from 'react';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/vite-plugin-utils.ts
function generateAppBootstrap(assetManifest, options) {
  const { appName, loadingTheme, customTheme } = options;
  const themeCSS = customTheme || (loadingTheme === "gradient" ? "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" : "background: #2c3e50;");
  return `/**
 * AppBootstrap.js - Generated by app-bootstrap-lib
 * Created: ${(/* @__PURE__ */ new Date()).toISOString()}
 */

(function() {
  'use strict';

  // Asset manifest
  window.ASSET_MANIFEST = ${JSON.stringify(assetManifest, null, 2)};

  // Loading state
  window.APP_BOOTSTRAP_LOADING_STATE = {
    isLoaded: false,
    isLoading: true,
    progress: 0,
    currentChunk: '',
    loadedChunks: [],
    totalChunks: ${assetManifest.loadingSequence.js.length},
    error: null,
    startTime: Date.now()
  };

  // Event emitter
  window.APP_BOOTSTRAP_EVENTS = {
    listeners: {},
    on: function(event, callback) {
      if (!this.listeners[event]) this.listeners[event] = [];
      this.listeners[event].push(callback);
    },
    emit: function(event, data) {
      if (this.listeners[event]) {
        this.listeners[event].forEach(cb => cb(data));
      }
    }
  };

  // Loading screen
  function createLoadingScreen() {
    const loadingHTML = \`
      <div id="loading-screen" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        ${themeCSS}
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        z-index: 9999;
      ">
        <div style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid white;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 20px;
        "></div>
        <p id="loading-text">Loading ${appName}...</p>
        <div id="loading-progress" style="
          width: 200px;
          height: 4px;
          background: rgba(255, 255, 255, 0.3);
          border-radius: 2px;
          margin-top: 10px;
          overflow: hidden;
        ">
          <div id="progress-bar" style="
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.3s ease;
          "></div>
        </div>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      </div>
    \`;

    document.body.insertAdjacentHTML('afterbegin', loadingHTML);
  }

  // Load assets
  async function loadAssets() {
    const { loadingSequence } = window.ASSET_MANIFEST;
    const totalChunks = loadingSequence.js.length + loadingSequence.css.length;
    let loadedChunks = 0;

    // Load CSS first
    for (const cssFile of loadingSequence.css) {
      try {
        await loadCSS(window.ASSET_MANIFEST.css[cssFile]);
        loadedChunks++;
        updateProgress(loadedChunks, totalChunks);
      } catch (error) {
        console.error('Failed to load CSS:', cssFile, error);
      }
    }

    // Load JS
    for (const jsFile of loadingSequence.js) {
      try {
        await loadJS(window.ASSET_MANIFEST.js[jsFile]);
        loadedChunks++;
        updateProgress(loadedChunks, totalChunks);
      } catch (error) {
        console.error('Failed to load JS:', jsFile, error);
      }
    }

    // Complete
    window.APP_BOOTSTRAP_LOADING_STATE.isLoaded = true;
    window.APP_BOOTSTRAP_LOADING_STATE.isLoading = false;
    window.APP_BOOTSTRAP_READY = true;

    window.APP_BOOTSTRAP_EVENTS.emit('loading:complete');
    hideLoadingScreen();
  }

  function loadCSS(href) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = href;
      link.onload = () => resolve();
      link.onerror = () => reject(new Error('CSS load failed: ' + href));
      document.head.appendChild(link);
    });
  }

  function loadJS(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error('JS load failed: ' + src));
      document.head.appendChild(script);
    });
  }

  function updateProgress(loaded: number, total: number) {
    const progress = Math.round((loaded / total) * 100);
    window.APP_BOOTSTRAP_LOADING_STATE.progress = progress;

    const progressBar = document.getElementById('progress-bar');
    if (progressBar) {
      progressBar.style.width = progress + '%';
    }

    window.APP_BOOTSTRAP_EVENTS.emit('loading:progress', { progress });
  }

  function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      loadingScreen.style.display = 'none';
    }
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      createLoadingScreen();
      loadAssets();
    });
  } else {
    createLoadingScreen();
    loadAssets();
  }
})();
`;
}
var init_vite_plugin_utils = __esm({
  "src/vite-plugin-utils.ts"() {
  }
});

// src/vite-plugin-server.ts
var vite_plugin_server_exports = {};
__export(vite_plugin_server_exports, {
  generateDevModeFiles: () => generateDevModeFiles
});
function generateDevModeFiles(opts, publicDir = "public") {
  const fs = __require("fs");
  const path = __require("path");
  const devAssetManifest = {
    js: {
      "main.js": "/src/main.tsx"
    },
    css: {},
    loadingSequence: {
      js: ["main.js"],
      css: []
    },
    totalOriginalSize: 0,
    buildInfo: {
      timestamp: Date.now(),
      version: "1.0.0-dev",
      appName: opts.appName,
      compressionEnabled: false,
      chunksGenerated: 1,
      plugin: "app-bootstrap-lib-dev"
    }
  };
  const devAppBootstrapContent = generateAppBootstrap(devAssetManifest, opts);
  const fullPublicDir = path.join(process.cwd(), publicDir);
  if (!fs.existsSync(fullPublicDir)) {
    fs.mkdirSync(fullPublicDir, { recursive: true });
  }
  const assetManifestPath = path.join(fullPublicDir, "asset-manifest.js");
  const assetManifestContent = `window.ASSET_MANIFEST = ${JSON.stringify(devAssetManifest, null, 2)};`;
  fs.writeFileSync(assetManifestPath, assetManifestContent);
  const appBootstrapPath = path.join(fullPublicDir, opts.bootstrapFileName);
  fs.writeFileSync(appBootstrapPath, devAppBootstrapContent);
  if (opts.debugMode) {
    console.log(`[app-bootstrap-lib] \u{1F4DD} Generated development files:`);
    console.log(`[app-bootstrap-lib] \u2705 ${opts.bootstrapFileName}`);
    console.log(`[app-bootstrap-lib] \u2705 asset-manifest.js`);
  }
}
var init_vite_plugin_server = __esm({
  "src/vite-plugin-server.ts"() {
    init_vite_plugin_utils();
  }
});

// src/vite.ts
init_vite_plugin_utils();

// src/workbox.ts
var DEFAULT_WORKBOX_OPTIONS = {
  enabled: true,
  cacheNamePrefix: "celebrity-box",
  strategies: {
    js: "stale-while-revalidate",
    css: "stale-while-revalidate",
    images: "cache-first",
    html: "network-first",
    api: "network-first"
  },
  expiration: {
    maxEntries: 100,
    maxAgeSeconds: 86400
    // 24 hours
  },
  precache: true,
  backgroundSync: false
};
function generateWorkboxServiceWorker(assetManifest, options, workboxOptions = {}) {
  const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };
  if (!opts.enabled) {
    return generateMinimalServiceWorker(assetManifest, options);
  }
  const cacheName = `${opts.cacheNamePrefix}-v1`;
  const { appName } = options;
  return `/**
 * Service Worker - Generated by @basirah/app-bootstrap-lib
 * App: ${appName}
 * Created: ${(/* @__PURE__ */ new Date()).toISOString()}
 */

const CACHE_NAME = '${cacheName}';
const STATIC_CACHE = '${cacheName}-static';
const DYNAMIC_CACHE = '${cacheName}-dynamic';

// Assets to precache
const PRECACHE_ASSETS = [
  '/',
  '/index.html',
  '/AppBootstrap.js',
  '/asset-manifest.js',
${assetManifest.loadingSequence.js.map((js) => `  '/${js}',`).join("\n")}
${assetManifest.loadingSequence.css.map((css) => `  '/${css}',`).join("\n")}
];

// Install event - precache assets
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('[SW] Pre-caching app shell');
        return cache.addAll(PRECACHE_ASSETS);
      })
      .then(() => {
        console.log('[SW] Successfully installed');
        return self.skipWaiting();
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
              console.log('[SW] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('[SW] Successfully activated');
        return self.clients.claim();
      })
  );
});

// Fetch event - handle requests
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Handle different file types with different strategies
  if (url.pathname.endsWith('.js')) {
    event.respondWith(handleJSRequest(request));
  } else if (url.pathname.endsWith('.css')) {
    event.respondWith(handleCSSRequest(request));
  } else if (url.pathname.match(/\\.(png|jpg|jpeg|svg|gif|ico)$/)) {
    event.respondWith(handleImageRequest(request));
  } else if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleAPIRequest(request));
  } else {
    event.respondWith(handleHTMLRequest(request));
  }
});

// Cache First strategy for images
async function handleImageRequest(request) {
  try {
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.error('[SW] Image fetch failed:', error);
    return new Response('Image not available', { status: 404 });
  }
}

// Stale While Revalidate for JS/CSS
async function handleJSRequest(request) {
  return handleStaleWhileRevalidate(request, STATIC_CACHE);
}

async function handleCSSRequest(request) {
  return handleStaleWhileRevalidate(request, STATIC_CACHE);
}

// Network First for HTML
async function handleHTMLRequest(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.log('[SW] Network failed, trying cache...');
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    return caches.match('/index.html');
  }
}

// Network First for API calls
async function handleAPIRequest(request) {
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.log('[SW] API network failed, trying cache...');
    return await caches.match(request);
  }
}

// Stale While Revalidate strategy
async function handleStaleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(request);

  const fetchPromise = fetch(request).then((networkResponse) => {
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  }).catch(() => {
    console.log('[SW] Network failed for:', request.url);
  });

  return cachedResponse || fetchPromise;
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    console.log('[SW] Background sync triggered');
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // Handle offline actions here
  console.log('[SW] Processing background sync...');
}

// Push notifications
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'New notification from ${appName}',
    icon: '/icon-192x192.png',
    badge: '/icon-192x192.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    }
  };

  event.waitUntil(
    self.registration.showNotification('${appName}', options)
  );
});

// Notification click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.openWindow('/')
  );
});

console.log('[SW] Service worker loaded successfully');
`;
}
function generateMinimalServiceWorker(_assetManifest, options) {
  return `/**
 * Minimal Service Worker - Generated by @basirah/app-bootstrap-lib
 * App: ${options.appName}
 * Created: ${(/* @__PURE__ */ new Date()).toISOString()}
 */

self.addEventListener('install', (event) => {
  console.log('[SW] Installing minimal service worker...');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating minimal service worker...');
  self.clients.claim();
});

self.addEventListener('fetch', (event) => {
  // Basic caching for offline support
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});

console.log('[SW] Minimal service worker loaded');
`;
}
function generateServiceWorkerRegistration(options, workboxOptions = {}) {
  const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };
  if (!opts.enabled) {
    return "";
  }
  return `/**
 * Service Worker Registration - Generated by @basirah/app-bootstrap-lib
 * App: ${options.appName}
 */

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('[SW] Registration successful:', registration.scope);

        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New content is available
              console.log('[SW] New content available');
              // You can show a notification to the user here
            }
          });
        });
      })
      .catch((error) => {
        console.error('[SW] Registration failed:', error);
      });
  });
}

// Background sync registration
if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
  navigator.serviceWorker.ready.then((registration) => {
    // Register background sync
    registration.sync.register('background-sync');
  });
}
`;
}
function generatePWAManifest(options, _workboxOptions = {}) {
  const manifest = {
    name: options.appName || "App",
    short_name: (options.appName || "App").replace(/\s+/g, "").substring(0, 12),
    description: `PWA for ${options.appName || "App"} with offline support`,
    theme_color: options.loadingTheme === "gradient" ? "#667eea" : "#2c3e50",
    background_color: "#ffffff",
    display: "standalone",
    orientation: "portrait",
    scope: "/",
    start_url: "/",
    icons: [
      {
        src: "/icon-192x192.png",
        sizes: "192x192",
        type: "image/png"
      },
      {
        src: "/icon-512x512.png",
        sizes: "512x512",
        type: "image/png"
      },
      {
        src: "/icon-512x512.png",
        sizes: "512x512",
        type: "image/png",
        purpose: "maskable"
      }
    ],
    categories: ["utilities", "productivity"],
    shortcuts: [
      {
        name: "Home",
        short_name: "Home",
        description: "Go to home page",
        url: "/",
        icons: [{ src: "/icon-192x192.png", sizes: "192x192" }]
      }
    ]
  };
  return JSON.stringify(manifest, null, 2);
}

// src/vite.ts
var DEFAULT_PRIORITIES = {
  "vendor": 1,
  "main": 2,
  "app": 3,
  "chunk": 4
};
function generateChunkConfiguration(customChunks = {}) {
  const chunks = {
    vendor: ["react", "react-dom"],
    ...customChunks
  };
  return chunks;
}
function analyzeBuildOutput(bundle, priorities, assetPrefix = "") {
  const js = {};
  const css = {};
  let totalOriginalSize = 0;
  for (const [fileName, file] of Object.entries(bundle)) {
    const fileInfo = file;
    const filePath = assetPrefix ? `${assetPrefix}/${fileName}` : `/${fileName}`;
    if (fileName.endsWith(".js")) {
      js[fileName] = filePath;
      totalOriginalSize += fileInfo.code?.length || 0;
    } else if (fileName.endsWith(".css")) {
      css[fileName] = filePath;
      totalOriginalSize += fileInfo.source?.length || 0;
    }
  }
  const loadingSequence = {
    js: Object.keys(js).sort((a, b) => {
      const priorityA = priorities[a] || 999;
      const priorityB = priorities[b] || 999;
      return priorityA - priorityB;
    }),
    css: Object.keys(css)
  };
  return {
    js,
    css,
    loadingSequence,
    totalOriginalSize,
    buildInfo: {
      timestamp: Date.now(),
      version: "1.0.0",
      appName: "App",
      compressionEnabled: false,
      chunksGenerated: Object.keys(js).length,
      plugin: "app-bootstrap-lib"
    }
  };
}
function transformIndexHtml(html, options) {
  const bootstrapScript = `<script src="/${options.bootstrapFileName}"></script>`;
  if (html.includes("</head>")) {
    return html.replace("</head>", `  ${bootstrapScript}
</head>`);
  }
  return bootstrapScript + "\n" + html;
}
function appBootstrapPlugin(options = {}) {
  let buildAssets;
  const opts = {
    enableGzip: false,
    enableProgress: true,
    enableFallback: true,
    debugMode: false,
    appName: "Application",
    appIcon: "\u26A1",
    loadingTheme: "gradient",
    customTheme: "",
    enableCDNFallback: false,
    compressionFirst: false,
    customChunks: {},
    chunkPriorities: {},
    assetPrefix: "",
    bootstrapFileName: "AppBootstrap.js",
    gzipLoaderConfig: {
      debugMode: false,
      useGzip: false,
      fallbackToUncompressed: true,
      timeout: 1e4,
      retries: 3
    },
    ...options
  };
  const priorities = { ...DEFAULT_PRIORITIES, ...opts.chunkPriorities };
  return {
    name: "app-bootstrap-lib",
    async configureServer(server) {
      console.log("[app-bootstrap-lib] \u{1F680} Development server starting, generating bootstrap files...");
      try {
        const { generateDevModeFiles: generateDevModeFiles2 } = await Promise.resolve().then(() => (init_vite_plugin_server(), vite_plugin_server_exports));
        const publicDir = server.config.publicDir || "public";
        console.log(`[app-bootstrap-lib] \u{1F4C1} Public directory: ${publicDir}`);
        generateDevModeFiles2(opts, publicDir);
      } catch (e) {
        console.error("[app-bootstrap-lib] Error generating dev mode files:", e);
      }
    },
    config(config) {
      if (!config.build) config.build = {};
      config.build.cssCodeSplit = true;
      if (!config.build.rollupOptions) config.build.rollupOptions = {};
      if (!config.build.rollupOptions.output) config.build.rollupOptions.output = {};
      const output = config.build.rollupOptions.output;
      output.entryFileNames = "[name].js";
      output.chunkFileNames = "[name].js";
      output.assetFileNames = (assetInfo) => {
        if (!assetInfo.name) return "[name].[ext]";
        const info = assetInfo.name.split(".");
        const ext = info[info.length - 1];
        if (/\.(css)$/.test(assetInfo.name)) {
          return `assets/[name].${ext}`;
        }
        return "[name].[ext]";
      };
      const chunks = generateChunkConfiguration(opts.customChunks);
      output.manualChunks = chunks;
      if (opts.debugMode) {
        console.log("[app-bootstrap-lib] App name:", opts.appName);
        console.log("[app-bootstrap-lib] Theme:", opts.loadingTheme);
      }
      return config;
    },
    transformIndexHtml(html) {
      return transformIndexHtml(html, opts);
    },
    generateBundle(_options, bundle) {
      buildAssets = analyzeBuildOutput(bundle, priorities, opts.assetPrefix);
      const assetManifest = {
        ...buildAssets,
        buildInfo: {
          ...buildAssets.buildInfo,
          appName: opts.appName,
          compressionEnabled: opts.enableGzip,
          plugin: "app-bootstrap-lib"
        }
      };
      this.emitFile({
        type: "asset",
        fileName: "asset-manifest.js",
        source: `window.ASSET_MANIFEST = ${JSON.stringify(assetManifest, null, 2)};`
      });
      const appBootstrapContent = generateAppBootstrap(assetManifest, opts);
      this.emitFile({
        type: "asset",
        fileName: opts.bootstrapFileName,
        source: appBootstrapContent
      });
      if (options.workbox?.enabled !== false) {
        const workboxOptions = options.workbox || {};
        const serviceWorkerContent = generateWorkboxServiceWorker(assetManifest, opts, workboxOptions);
        this.emitFile({
          type: "asset",
          fileName: "sw.js",
          source: serviceWorkerContent
        });
        const manifestContent = generatePWAManifest(opts, workboxOptions);
        this.emitFile({
          type: "asset",
          fileName: "manifest.webmanifest",
          source: manifestContent
        });
        const registrationScript = generateServiceWorkerRegistration(opts, workboxOptions);
        if (registrationScript) {
          this.emitFile({
            type: "asset",
            fileName: "registerSW.js",
            source: registrationScript
          });
        }
        if (opts.debugMode) {
          console.log(`[app-bootstrap-lib] \u{1F527} Generated Workbox service worker`);
          console.log(`[app-bootstrap-lib] \u{1F4F1} Generated PWA manifest`);
        }
      }
      if (opts.debugMode) {
        console.log(`[app-bootstrap-lib] \u2705 Generated ${opts.bootstrapFileName}`);
        console.log(`[app-bootstrap-lib] \u{1F4E6} Assets: ${Object.keys(buildAssets.js).length} JS, ${Object.keys(buildAssets.css).length} CSS`);
      }
    }
  };
}
var AppBootstrapEvents = class {
  constructor() {
    this.listeners = {};
  }
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
    return () => {
      this.listeners[event] = this.listeners[event].filter((cb) => cb !== callback);
    };
  }
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach((callback) => callback(data));
    }
  }
};
var appBootstrapEvents = new AppBootstrapEvents();
function getAssetManifest() {
  return window.ASSET_MANIFEST || null;
}
function isAppBootstrapReady() {
  return window.APP_BOOTSTRAP_READY === true;
}
function getCurrentLoadingState() {
  return window.APP_BOOTSTRAP_LOADING_STATE || null;
}
function useAppBootstrap(config = {}) {
  const [loadingState, setLoadingState] = useState({
    isLoaded: false,
    isLoading: false,
    progress: 0,
    currentChunk: "",
    loadedChunks: [],
    totalChunks: 0,
    error: null,
    startTime: Date.now()
  });
  const [assetManifest, setAssetManifest] = useState(null);
  const [error, setError] = useState(null);
  const isReady = useRef(false);
  useEffect(() => {
    const currentState = getCurrentLoadingState();
    const currentManifest = getAssetManifest();
    if (currentState) {
      setLoadingState(currentState);
    }
    if (currentManifest) {
      setAssetManifest(currentManifest);
    }
    if (isAppBootstrapReady()) {
      isReady.current = true;
      setLoadingState((prev) => ({
        ...prev,
        isLoaded: true,
        isLoading: false,
        progress: 100
      }));
    }
  }, []);
  useEffect(() => {
    const unsubscribeStart = appBootstrapEvents.on("loading:start", (_event) => {
      setLoadingState((prev) => ({
        ...prev,
        isLoading: true,
        isLoaded: false,
        startTime: Date.now(),
        error: null
      }));
      setError(null);
    });
    const unsubscribeProgress = appBootstrapEvents.on("loading:progress", (event) => {
      setLoadingState((prev) => ({
        ...prev,
        progress: event.data?.progress || prev.progress
      }));
    });
    const unsubscribeComplete = appBootstrapEvents.on("loading:complete", (_event) => {
      isReady.current = true;
      setLoadingState((prev) => ({
        ...prev,
        isLoaded: true,
        isLoading: false,
        progress: 100,
        endTime: Date.now(),
        duration: Date.now() - prev.startTime
      }));
    });
    const unsubscribeError = appBootstrapEvents.on("loading:error", (event) => {
      const errorMessage = event.data?.error || "Unknown loading error";
      setError(errorMessage);
      setLoadingState((prev) => ({
        ...prev,
        isLoading: false,
        error: errorMessage
      }));
    });
    const unsubscribeManifestLoaded = appBootstrapEvents.on("manifest:loaded", (event) => {
      setAssetManifest(event.data?.manifest);
    });
    return () => {
      unsubscribeStart();
      unsubscribeProgress();
      unsubscribeComplete();
      unsubscribeError();
      unsubscribeManifestLoaded();
    };
  }, []);
  useEffect(() => {
    if (assetManifest || !config.enableDebug) return;
    const pollInterval = setInterval(() => {
      const manifest = getAssetManifest();
      if (manifest) {
        setAssetManifest(manifest);
        clearInterval(pollInterval);
      }
    }, 100);
    return () => clearInterval(pollInterval);
  }, [assetManifest, config.enableDebug]);
  useEffect(() => {
    if (isReady.current) return;
    const checkDevReady = () => {
      const rootElement = document.getElementById("root");
      if (rootElement && rootElement.children.length > 0) {
        const appContent = rootElement.querySelector(".app, .home-page, .system-config-page, .video-player-page");
        if (appContent) {
          console.log("[useAppBootstrap] Development mode: App content detected, marking as ready");
          isReady.current = true;
          setLoadingState((prev) => ({
            ...prev,
            isLoaded: true,
            isLoading: false,
            progress: 100,
            endTime: Date.now(),
            duration: Date.now() - prev.startTime
          }));
          return true;
        }
      }
      return false;
    };
    if (checkDevReady()) return;
    const pollInterval = setInterval(() => {
      if (checkDevReady()) {
        clearInterval(pollInterval);
      }
    }, 100);
    const timeout = setTimeout(() => {
      clearInterval(pollInterval);
      if (!isReady.current) {
        console.log("[useAppBootstrap] Development mode: Fallback timeout, marking as ready");
        isReady.current = true;
        setLoadingState((prev) => ({
          ...prev,
          isLoaded: true,
          isLoading: false,
          progress: 100,
          endTime: Date.now(),
          duration: Date.now() - prev.startTime
        }));
      }
    }, 3e3);
    return () => {
      clearInterval(pollInterval);
      clearTimeout(timeout);
    };
  }, []);
  const retry = useCallback(() => {
    setError(null);
    setLoadingState((prev) => ({
      ...prev,
      error: null,
      isLoading: true,
      isLoaded: false,
      startTime: Date.now()
    }));
    appBootstrapEvents.emit("loading:retry", { timestamp: Date.now() });
  }, []);
  const getChunkProgress = useCallback((chunkName) => {
    if (!assetManifest) return 0;
    const chunk = assetManifest.js[chunkName];
    return chunk ? 100 : 0;
  }, [assetManifest]);
  const getOverallProgress = useCallback(() => {
    return loadingState.progress;
  }, [loadingState.progress]);
  useEffect(() => {
    if (config.enableDebug) {
      console.log("[useAppBootstrap] Loading state:", loadingState);
      console.log("[useAppBootstrap] Asset manifest:", assetManifest);
      console.log("[useAppBootstrap] Error:", error);
    }
  }, [loadingState, assetManifest, error, config.enableDebug]);
  return {
    loadingState,
    assetManifest,
    isReady: isReady.current,
    error,
    retry,
    getChunkProgress,
    getOverallProgress
  };
}
function useAppBootstrapStatus() {
  const { loadingState, isReady, error } = useAppBootstrap();
  return {
    isReady,
    isLoading: loadingState.isLoading,
    isLoaded: loadingState.isLoaded,
    progress: loadingState.progress,
    error,
    currentChunk: loadingState.currentChunk
  };
}
function useAppBootstrapWithConfig(config) {
  return useAppBootstrap(config);
}

// src/cache.ts
var AppCacheManager = class {
  constructor(config = {}) {
    this.config = {
      cacheName: "app-bootstrap-v1",
      appVersion: "1.0.0",
      enableServiceWorker: true,
      loadingScreen: {
        theme: "gradient"
      },
      ...config
    };
    this.loadingElement = null;
  }
  async init() {
    console.log("App Cache Manager initializing...");
    this.setupLoadingScreen();
    await this.loadApp();
  }
  setupLoadingScreen() {
    const theme = this.config.loadingScreen?.theme || "gradient";
    const customHTML = this.config.loadingScreen?.customHTML;
    const loadingHTML = customHTML || this.getDefaultLoadingHTML(theme);
    document.body.insertAdjacentHTML("afterbegin", loadingHTML);
    this.loadingElement = document.getElementById("loading-screen");
  }
  getDefaultLoadingHTML(theme) {
    const baseStyles = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      z-index: 9999;
    `;
    const background = theme === "gradient" ? "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);" : "background: #2c3e50;";
    return `
      <div id="loading-screen" style="${baseStyles} ${background}">
        <div style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid white;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 20px;
        "></div>
        <p id="loading-text">Loading Application...</p>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      </div>
    `;
  }
  updateLoadingText(text) {
    const loadingText = document.getElementById("loading-text");
    if (loadingText) {
      loadingText.textContent = text;
    }
  }
  async loadApp() {
    this.updateLoadingText("Loading application...");
    setTimeout(() => {
      this.hideLoadingScreen();
    }, 2e3);
  }
  hideLoadingScreen() {
    if (this.loadingElement) {
      this.loadingElement.style.display = "none";
    }
  }
  showError(message) {
    if (this.loadingElement) {
      this.loadingElement.innerHTML = `
        <div style="text-align: center;">
          <h3>Error</h3>
          <p>${message}</p>
          <button onclick="location.reload()" style="
            background: white;
            color: #667eea;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
          ">Retry</button>
        </div>
      `;
    }
  }
  retry() {
    location.reload();
  }
  // Service Worker registration - removed to simplify
};
function initializeCacheManager(config) {
  const manager = new AppCacheManager(config);
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      manager.init();
    });
  } else {
    manager.init();
  }
  return manager;
}

export { AppCacheManager, appBootstrapEvents, appBootstrapPlugin, generatePWAManifest, generateServiceWorkerRegistration, generateWorkboxServiceWorker, initializeCacheManager, useAppBootstrap, useAppBootstrapStatus, useAppBootstrapWithConfig, appBootstrapPlugin as vitePlugin };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map