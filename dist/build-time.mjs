import * as fs from 'fs';
import * as path from 'path';

// src/asset-manifest.ts
var AssetManifestGenerator = class {
  constructor(distDir, outputFile) {
    this.distDir = distDir;
    this.outputFile = outputFile;
    this.manifest = {
      css: {},
      js: {},
      assets: {},
      buildInfo: {
        timestamp: Date.now(),
        version: "1.0.0",
        compressionRatio: 0,
        totalOriginalSize: 0,
        totalCompressedSize: 0
      }
    };
  }
  /**
   * Generate the complete asset manifest
   */
  async generate() {
    console.log("\u{1F50D} Scanning build directory:", this.distDir);
    if (!fs.existsSync(this.distDir)) {
      throw new Error(`Build directory not found: ${this.distDir}`);
    }
    await this.scanDirectory(this.distDir);
    this.calculateCompressionStats();
    this.writeManifest();
    console.log("\u2705 Asset manifest generated successfully!");
    this.printStats();
  }
  /**
   * Recursively scan directory for assets
   */
  async scanDirectory(dir, relativePath = "") {
    const items = fs.readdirSync(dir);
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const relativeFilePath = path.join(relativePath, item).replace(/\\/g, "/");
      const webPath = "/" + relativeFilePath;
      if (fs.statSync(fullPath).isDirectory()) {
        await this.scanDirectory(fullPath, relativeFilePath);
      } else {
        await this.processFile(fullPath, webPath);
      }
    }
  }
  /**
   * Extract logical name from hashed filename
   * e.g., "vendor-l0sNRNKZ.js" -> "vendor.js"
   */
  getLogicalName(fileName) {
    const hashPattern = /-[a-zA-Z0-9]{8,}/;
    return fileName.replace(hashPattern, "");
  }
  /**
   * Process individual file
   */
  async processFile(filePath, webPath) {
    const ext = path.extname(filePath).toLowerCase();
    const fileName = path.basename(filePath);
    if (ext === ".gz") {
      return;
    }
    const stats = fs.statSync(filePath);
    const gzipPath = filePath + ".gz";
    const hasGzip = fs.existsSync(gzipPath);
    let gzipSize = 0;
    if (hasGzip) {
      gzipSize = fs.statSync(gzipPath).size;
    }
    let logicalPath = webPath;
    if ((webPath.includes("/assets/") || webPath.startsWith("/workbox")) && (ext === ".js" || ext === ".css")) {
      const logicalFileName = this.getLogicalName(fileName);
      logicalPath = webPath.replace(fileName, logicalFileName);
    }
    const assetInfo = {
      original: webPath,
      // The actual hashed filename
      logical: logicalPath,
      // The logical name clients will request
      gzipped: hasGzip ? webPath + ".gz" : null,
      size: stats.size,
      gzipSize,
      compressionRatio: hasGzip ? Number(((stats.size - gzipSize) / stats.size * 100).toFixed(1)) : 0
    };
    if (ext === ".css") {
      this.manifest.css[logicalPath] = assetInfo;
      console.log(`\u{1F4C4} CSS: ${logicalPath} \u2192 ${webPath} (${this.formatSize(stats.size)} \u2192 ${this.formatSize(gzipSize)})`);
    } else if (ext === ".js") {
      this.manifest.js[logicalPath] = assetInfo;
      console.log(`\u{1F4DC} JS: ${logicalPath} \u2192 ${webPath} (${this.formatSize(stats.size)} \u2192 ${this.formatSize(gzipSize)})`);
    } else if (this.isAssetFile(ext)) {
      this.manifest.assets[logicalPath] = assetInfo;
      console.log(`\u{1F5BC}\uFE0F Asset: ${logicalPath} (${this.formatSize(stats.size)})`);
    }
    this.manifest.buildInfo.totalOriginalSize += stats.size;
    this.manifest.buildInfo.totalCompressedSize += gzipSize || stats.size;
  }
  /**
   * Check if file is an asset (image, font, etc.)
   */
  isAssetFile(ext) {
    const assetExtensions = [
      ".png",
      ".jpg",
      ".jpeg",
      ".gif",
      ".svg",
      ".webp",
      ".ico",
      ".woff",
      ".woff2",
      ".ttf",
      ".eot",
      ".json",
      ".webmanifest",
      ".txt",
      ".html"
    ];
    return assetExtensions.includes(ext);
  }
  /**
   * Calculate overall compression statistics
   */
  calculateCompressionStats() {
    const { totalOriginalSize, totalCompressedSize } = this.manifest.buildInfo;
    if (totalOriginalSize > 0) {
      this.manifest.buildInfo.compressionRatio = Number(((totalOriginalSize - totalCompressedSize) / totalOriginalSize * 100).toFixed(1));
    }
  }
  /**
   * Write the manifest file
   */
  writeManifest() {
    const manifestContent = `/**
 * Asset Manifest - Dynamic Asset Mapping
 * This file is populated during the build process with actual hashed filenames
 * DO NOT EDIT MANUALLY - Generated by app-bootstrap-lib
 * Generated: ${(/* @__PURE__ */ new Date()).toISOString()}
 */

// Dynamic asset mappings with actual hashed filenames
window.ASSET_MANIFEST = ${JSON.stringify(this.manifest, null, 4)};

// Helper function to get asset info by logical path
window.getAssetInfo = function(path) {
  const categories = ['css', 'js', 'assets'];

  for (const category of categories) {
    if (window.ASSET_MANIFEST[category] && window.ASSET_MANIFEST[category][path]) {
      return window.ASSET_MANIFEST[category][path];
    }
  }

  return null;
};

// Helper function to get actual file path (handles logical->actual mapping)
window.getActualPath = function(path) {
  const assetInfo = window.getAssetInfo(path);
  return assetInfo ? assetInfo.original : path;
};

// Helper function to get gzipped path
window.getGzippedPath = function(path) {
  const assetInfo = window.getAssetInfo(path);
  return assetInfo && assetInfo.gzipped ? assetInfo.gzipped : null;
};

// Helper function to check if gzip is available
window.hasGzipVersion = function(path) {
  const assetInfo = window.getAssetInfo(path);
  return assetInfo && assetInfo.gzipped !== null;
};

console.log('Asset manifest loaded:', window.ASSET_MANIFEST.buildInfo);
`;
    fs.writeFileSync(this.outputFile, manifestContent, "utf8");
    console.log("\u{1F4BE} Manifest written to:", this.outputFile);
  }
  /**
   * Format file size for display
   */
  formatSize(bytes) {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
  }
  /**
   * Print compression statistics
   */
  printStats() {
    const { totalOriginalSize, totalCompressedSize, compressionRatio } = this.manifest.buildInfo;
    console.log("\n\u{1F4CA} Compression Statistics:");
    console.log(`   Original Size: ${this.formatSize(totalOriginalSize)}`);
    console.log(`   Compressed Size: ${this.formatSize(totalCompressedSize)}`);
    console.log(`   Compression Ratio: ${compressionRatio}%`);
    console.log(`   Space Saved: ${this.formatSize(totalOriginalSize - totalCompressedSize)}`);
    const cssCount = Object.keys(this.manifest.css).length;
    const jsCount = Object.keys(this.manifest.js).length;
    const assetCount = Object.keys(this.manifest.assets).length;
    console.log("\n\u{1F4C1} File Counts:");
    console.log(`   CSS Files: ${cssCount}`);
    console.log(`   JS Files: ${jsCount}`);
    console.log(`   Other Assets: ${assetCount}`);
    console.log(`   Total Files: ${cssCount + jsCount + assetCount}`);
  }
  /**
   * Get the generated manifest
   */
  getManifest() {
    return this.manifest;
  }
};
async function generateAssetManifest(distDir = "./dist", outputFile) {
  const defaultOutputFile = path.join(distDir, "asset-manifest.js");
  const finalOutputFile = outputFile || defaultOutputFile;
  console.log("\u{1F680} Starting Asset Manifest Generation...");
  console.log(`   Build Directory: ${distDir}`);
  console.log(`   Output File: ${finalOutputFile}`);
  const generator = new AssetManifestGenerator(distDir, finalOutputFile);
  await generator.generate();
}
if (typeof process !== "undefined" && process.argv && process.argv[1] && process.argv[1].includes("asset-manifest")) {
  const args = process.argv.slice(2);
  const distDir = args[0] || "./dist";
  const outputFile = args[1];
  generateAssetManifest(distDir, outputFile).catch((error) => {
    console.error("\u274C Error generating asset manifest:", error);
    process.exit(1);
  });
}

export { AssetManifestGenerator, generateAssetManifest };
//# sourceMappingURL=build-time.mjs.map
//# sourceMappingURL=build-time.mjs.map