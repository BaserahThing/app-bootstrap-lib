{"version":3,"sources":["../src/workbox.ts"],"names":[],"mappings":"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","file":"workbox.mjs","sourcesContent":["/**\n * Workbox Integration for App Bootstrap Library\n * Created: 2024-07-31\n * Purpose: Provides PWA functionality with service worker generation and caching strategies\n */\n\nimport type { AppBootstrapOptions, AssetManifest } from './types';\n\nexport interface WorkboxOptions {\n    /** Enable/disable Workbox integration */\n    enabled?: boolean;\n    /** Cache name prefix */\n    cacheNamePrefix?: string;\n    /** Cache strategies for different file types */\n    strategies?: {\n        /** Strategy for JavaScript files */\n        js?: 'cache-first' | 'stale-while-revalidate' | 'network-first';\n        /** Strategy for CSS files */\n        css?: 'cache-first' | 'stale-while-revalidate' | 'network-first';\n        /** Strategy for images */\n        images?: 'cache-first' | 'stale-while-revalidate' | 'network-first';\n        /** Strategy for HTML files */\n        html?: 'cache-first' | 'stale-while-revalidate' | 'network-first';\n        /** Strategy for API calls */\n        api?: 'cache-first' | 'stale-while-revalidate' | 'network-first';\n    };\n    /** Cache expiration settings */\n    expiration?: {\n        /** Maximum number of entries in cache */\n        maxEntries?: number;\n        /** Maximum age in seconds */\n        maxAgeSeconds?: number;\n    };\n    /** Precache assets */\n    precache?: boolean;\n    /** Background sync for offline actions */\n    backgroundSync?: boolean;\n}\n\nconst DEFAULT_WORKBOX_OPTIONS: Required<WorkboxOptions> = {\n    enabled: true,\n    cacheNamePrefix: 'celebrity-box',\n    strategies: {\n        js: 'stale-while-revalidate',\n        css: 'stale-while-revalidate',\n        images: 'cache-first',\n        html: 'network-first',\n        api: 'network-first'\n    },\n    expiration: {\n        maxEntries: 100,\n        maxAgeSeconds: 86400 // 24 hours\n    },\n    precache: true,\n    backgroundSync: false\n};\n\n/**\n * Generate Workbox service worker content\n */\nexport function generateWorkboxServiceWorker(\n    assetManifest: AssetManifest,\n    options: AppBootstrapOptions,\n    workboxOptions: WorkboxOptions = {}\n): string {\n    const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };\n\n    if (!opts.enabled) {\n        return generateMinimalServiceWorker(assetManifest, options);\n    }\n\n    const cacheName = `${opts.cacheNamePrefix}-v1`;\n    const { appName } = options;\n\n    return `/**\n * Service Worker - Generated by @basirah/app-bootstrap-lib\n * App: ${appName}\n * Created: ${new Date().toISOString()}\n */\n\nconst CACHE_NAME = '${cacheName}';\nconst STATIC_CACHE = '${cacheName}-static';\nconst DYNAMIC_CACHE = '${cacheName}-dynamic';\n\n// Assets to precache\nconst PRECACHE_ASSETS = [\n  '/',\n  '/index.html',\n  '/AppBootstrap.js',\n  '/asset-manifest.js',\n${assetManifest.loadingSequence.js.map(js => `  '/${js}',`).join('\\n')}\n${assetManifest.loadingSequence.css.map(css => `  '/${css}',`).join('\\n')}\n];\n\n// Install event - precache assets\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker...');\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n      .then((cache) => {\n        console.log('[SW] Pre-caching app shell');\n        return cache.addAll(PRECACHE_ASSETS);\n      })\n      .then(() => {\n        console.log('[SW] Successfully installed');\n        return self.skipWaiting();\n      })\n  );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker...');\n  event.waitUntil(\n    caches.keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => {\n        console.log('[SW] Successfully activated');\n        return self.clients.claim();\n      })\n  );\n});\n\n// Fetch event - handle requests\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests\n  if (request.method !== 'GET') {\n    return;\n  }\n\n  // Handle different file types with different strategies\n  if (url.pathname.endsWith('.js')) {\n    event.respondWith(handleJSRequest(request));\n  } else if (url.pathname.endsWith('.css')) {\n    event.respondWith(handleCSSRequest(request));\n  } else if (url.pathname.match(/\\\\.(png|jpg|jpeg|svg|gif|ico)$/)) {\n    event.respondWith(handleImageRequest(request));\n  } else if (url.pathname.startsWith('/api/')) {\n    event.respondWith(handleAPIRequest(request));\n  } else {\n    event.respondWith(handleHTMLRequest(request));\n  }\n});\n\n// Cache First strategy for images\nasync function handleImageRequest(request) {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      const cache = await caches.open(DYNAMIC_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.error('[SW] Image fetch failed:', error);\n    return new Response('Image not available', { status: 404 });\n  }\n}\n\n// Stale While Revalidate for JS/CSS\nasync function handleJSRequest(request) {\n  return handleStaleWhileRevalidate(request, STATIC_CACHE);\n}\n\nasync function handleCSSRequest(request) {\n  return handleStaleWhileRevalidate(request, STATIC_CACHE);\n}\n\n// Network First for HTML\nasync function handleHTMLRequest(request) {\n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      const cache = await caches.open(DYNAMIC_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.log('[SW] Network failed, trying cache...');\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n    return caches.match('/index.html');\n  }\n}\n\n// Network First for API calls\nasync function handleAPIRequest(request) {\n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok) {\n      const cache = await caches.open(DYNAMIC_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.log('[SW] API network failed, trying cache...');\n    return await caches.match(request);\n  }\n}\n\n// Stale While Revalidate strategy\nasync function handleStaleWhileRevalidate(request, cacheName) {\n  const cache = await caches.open(cacheName);\n  const cachedResponse = await cache.match(request);\n\n  const fetchPromise = fetch(request).then((networkResponse) => {\n    if (networkResponse.ok) {\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  }).catch(() => {\n    console.log('[SW] Network failed for:', request.url);\n  });\n\n  return cachedResponse || fetchPromise;\n}\n\n// Background sync for offline actions\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'background-sync') {\n    console.log('[SW] Background sync triggered');\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\nasync function doBackgroundSync() {\n  // Handle offline actions here\n  console.log('[SW] Processing background sync...');\n}\n\n// Push notifications\nself.addEventListener('push', (event) => {\n  const options = {\n    body: event.data ? event.data.text() : 'New notification from ${appName}',\n    icon: '/icon-192x192.png',\n    badge: '/icon-192x192.png',\n    vibrate: [100, 50, 100],\n    data: {\n      dateOfArrival: Date.now(),\n      primaryKey: 1\n    }\n  };\n\n  event.waitUntil(\n    self.registration.showNotification('${appName}', options)\n  );\n});\n\n// Notification click\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close();\n  event.waitUntil(\n    clients.openWindow('/')\n  );\n});\n\nconsole.log('[SW] Service worker loaded successfully');\n`;\n}\n\n/**\n * Generate minimal service worker (fallback)\n */\nfunction generateMinimalServiceWorker(\n  _assetManifest: AssetManifest,\n  options: AppBootstrapOptions\n): string {\n    return `/**\n * Minimal Service Worker - Generated by @basirah/app-bootstrap-lib\n * App: ${options.appName}\n * Created: ${new Date().toISOString()}\n */\n\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing minimal service worker...');\n  self.skipWaiting();\n});\n\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating minimal service worker...');\n  self.clients.claim();\n});\n\nself.addEventListener('fetch', (event) => {\n  // Basic caching for offline support\n  event.respondWith(\n    caches.match(event.request)\n      .then((response) => {\n        return response || fetch(event.request);\n      })\n  );\n});\n\nconsole.log('[SW] Minimal service worker loaded');\n`;\n}\n\n/**\n * Generate service worker registration script\n */\nexport function generateServiceWorkerRegistration(\n    options: AppBootstrapOptions,\n    workboxOptions: WorkboxOptions = {}\n): string {\n    const opts = { ...DEFAULT_WORKBOX_OPTIONS, ...workboxOptions };\n\n    if (!opts.enabled) {\n        return '';\n    }\n\n    return `/**\n * Service Worker Registration - Generated by @basirah/app-bootstrap-lib\n * App: ${options.appName}\n */\n\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/sw.js')\n      .then((registration) => {\n        console.log('[SW] Registration successful:', registration.scope);\n\n        // Handle updates\n        registration.addEventListener('updatefound', () => {\n          const newWorker = registration.installing;\n          newWorker.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              // New content is available\n              console.log('[SW] New content available');\n              // You can show a notification to the user here\n            }\n          });\n        });\n      })\n      .catch((error) => {\n        console.error('[SW] Registration failed:', error);\n      });\n  });\n}\n\n// Background sync registration\nif ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n  navigator.serviceWorker.ready.then((registration) => {\n    // Register background sync\n    registration.sync.register('background-sync');\n  });\n}\n`;\n}\n\n/**\n * Generate PWA manifest with Workbox integration\n */\nexport function generatePWAManifest(\n  options: AppBootstrapOptions,\n  _workboxOptions: WorkboxOptions = {}\n): string {\n  const manifest = {\n    name: options.appName || 'App',\n    short_name: (options.appName || 'App').replace(/\\s+/g, '').substring(0, 12),\n    description: `PWA for ${options.appName || 'App'} with offline support`,\n    theme_color: options.loadingTheme === 'gradient' ? '#667eea' : '#2c3e50',\n    background_color: '#ffffff',\n    display: 'standalone',\n    orientation: 'portrait',\n    scope: '/',\n    start_url: '/',\n    icons: [\n      {\n        src: '/icon-192x192.png',\n        sizes: '192x192',\n        type: 'image/png'\n      },\n      {\n        src: '/icon-512x512.png',\n        sizes: '512x512',\n        type: 'image/png'\n      },\n      {\n        src: '/icon-512x512.png',\n        sizes: '512x512',\n        type: 'image/png',\n        purpose: 'maskable'\n      }\n    ],\n    categories: ['utilities', 'productivity'],\n    shortcuts: [\n      {\n        name: 'Home',\n        short_name: 'Home',\n        description: 'Go to home page',\n        url: '/',\n        icons: [{ src: '/icon-192x192.png', sizes: '192x192' }]\n      }\n    ]\n  };\n\n  return JSON.stringify(manifest, null, 2);\n}\n"]}